
Goal: refactor generated code for usart initialization.

1. 	Do some analysis. DONE.
2. 	Planing to test HAL_UART_MspInit().
3. 	The first case says uart clock should be enabled after the function is called.
	call HAL_UART_MspInit(huart), compilation error.
	declare and initialize a test struct. (copy code from MX_USART2_UART_Init), compilation pass.
	add test case to test group runner and call group runner in main.c
4.	Add tool function uart_clock_enabled(), add assertion, test failed.
5.	recover uart enable in mspinit, failed. 
	mx_usart2_init commented out in main.c
	usart_clock_enabled bugs fixed. 
	Test passed.
6.	Now i want to add gpio init, but wait, what about the setup and teardown? for the sake of independent and repeatable.
	If we do UartClockShouldBeEnabled multiple times, though all tests should pass, they are not in the right context we expect.
	We want set up the 'clear' stage, what we mean by clear? no clock, no gpio, no dma, no irq, no uart. Good. but should we go
	that far now? I think not. we can simply disable the clock. Maybe sometime we will move the code to setup, or encapsulate, whatever,
	refactor maybe, but now a simple __USART2_CLK_DISABLE as the BUILD is enough. build and test pass.
7.	A little refactor. add a function in test file, uart_clock_disable(). do replacement, build and test pass.
8.	A little more refactor. use pointer other than struct/object.
9.	Before enabling GPIO init in production code. add a test case, assert in a tricky way. rename the test case. 
	GpioShouldBeConfigured renamed to GpioShouldBeNonInput, partial test because we trust the code.
	Test and fail.
10.	Add test case for rx dma, the globals are duplicated, as well as extern-ed. dirty. test and fail.
11. enabled rx dma and passed.
12. add test case for rx dma/uart link check, failed.
13.	enabled rx dma/uart link in production code, test failed. bug found in test assertion. cleared.
14. add test case for tx dma, test failed, then enable tx dma init in production code, test passed.
15.	add test case for tx dma/uart link, enabling production code, test passed.
16. in this step, we add a task to pending list, move SetPriorityGroup elsewhere.
17. in this step, we add a task to pending list, we think the priority should be parameterized.
18. add test case for irq enable. passed.
19. Do a summary
	a) gpio_init struct should be parameterized.
	b) dma init should be parameterized.
	c) SetPriorityGroup not neccessary.
	d) irq parameter should not be hard coded.
	and lets go, do container_of trick.
20. add uartex_handletypedef struct and initialized object (for test.)
21. gpio_init inside mspinit refactored, test passed.
22. use static instance to substitute global dma rx init, two tests failed.
23. typo bug, cleared. one test case obsolete.
24. use static instance to substitute global dma tx init, one case obsolete. passed.
25. add a struct for uart irq config. modify production code. passed.
26. a bit messy, right? let's clean it first.
	rename uart_clock_disable -> HAL_UART_ClockDisable, move to production code.
	rename uart_clock_enabled -> HAL_UART_ClockIsEnabled, move to production code.
	add test case for clock disable, new function HAL_UART_ClockEnable, compilation fails.
27.	add production code for HAL_UART_ClockEnable, test passed. add new test case for Enable, test passed.
28. we can do more refactor now, with this enable/disable code.


Pending: 
1. we don't like the local configuration struct hard coded inside mspinit. not flexible for test and user.
2. we don't like the way dma globals are used in mspinit. not good for test.
3. move SetPriorityGroup out of hal_uart_mspinit.
4. add a test case to mspinit with parameterized priority.

Task:
1. setup and teardown code.
2. uart clock enable/disable.
3. feature: dma irq should be set in uart.
4. feature: dma clock should be get/put pattern.




