
Goal: refactor generated code for usart initialization.

1. 	Do some analysis. DONE.
2. 	Planing to test HAL_UART_MspInit().
3. 	The first case says uart clock should be enabled after the function is called.
	call HAL_UART_MspInit(huart), compilation error.
	declare and initialize a test struct. (copy code from MX_USART2_UART_Init), compilation pass.
	add test case to test group runner and call group runner in main.c
4.	Add tool function uart_clock_enabled(), add assertion, test failed.
5.	recover uart enable in mspinit, failed. 
	mx_usart2_init commented out in main.c
	usart_clock_enabled bugs fixed. 
	Test passed.
6.	Now i want to add gpio init, but wait, what about the setup and teardown? for the sake of independent and repeatable.
	If we do UartClockShouldBeEnabled multiple times, though all tests should pass, they are not in the right context we expect.
	We want set up the 'clear' stage, what we mean by clear? no clock, no gpio, no dma, no irq, no uart. Good. but should we go
	that far now? I think not. we can simply disable the clock. Maybe sometime we will move the code to setup, or encapsulate, whatever,
	refactor maybe, but now a simple __USART2_CLK_DISABLE as the BUILD is enough. build and test pass.
7.	A little refactor. add a function in test file, uart_clock_disable(). do replacement, build and test pass.
8.	A little more refactor. use pointer other than struct/object.
9.	Before enabling GPIO init in production code. add a test case, assert in a tricky way. rename the test case. 
	GpioShouldBeConfigured renamed to GpioShouldBeNonInput, partial test because we trust the code.
	Test and fail.
10.	Add test case for rx dma, the globals are duplicated, as well as extern-ed. dirty. test and fail.



Pending: 
1. we don't like the local configuration struct hard coded inside mspinit. not flexible for test and user.
2. we don't like the way dma globals are used in mspinit. not good for test.


